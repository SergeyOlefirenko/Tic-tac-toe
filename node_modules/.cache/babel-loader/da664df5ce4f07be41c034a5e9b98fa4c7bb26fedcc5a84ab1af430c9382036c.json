{"ast":null,"code":"// import { DIMS, DRAW } from \"./minimax\";\n\n// export default class Board {\n//   constructor(grid) {\n//     this.grid = grid || new Array(DIMS ** 2).fill(null);\n//     this.winningIndex = null;\n//   }\n\n//   makeMove = (square, player) => {\n//     if (this.grid[square] === null) {\n//       this.grid[square] = player;\n//     }\n//   };\n\n//   // Collect indices of empty squares and return them\n//   getEmptySquares = (grid = this.grid) => {\n//     let squares = [];\n//     grid.forEach((square, i) => {\n//       if (square === null) squares.push(i);\n//     });\n//     return squares;\n//   };\n\n//   isEmpty = (grid = this.grid) => {\n//     return this.getEmptySquares(grid).length === DIMS ** 2;\n//   };\n\n//   getWinner = (grid = this.grid) => {\n//     const winningCombos = [\n//       [0, 1, 2],\n//       [3, 4, 5],\n//       [6, 7, 8],\n//       [0, 3, 6],\n//       [1, 4, 7],\n//       [2, 5, 8],\n//       [0, 4, 8],\n//       [2, 4, 6]\n//     ];\n//     let res = null;\n//     winningCombos.forEach((el, i) => {\n//       if (\n//         grid[el[0]] !== null &&\n//         grid[el[0]] === grid[el[1]] &&\n//         grid[el[0]] === grid[el[2]]\n//       ) {\n//         res = grid[el[0]];\n//         this.winningIndex = i;\n//       } else if (res === null && this.getEmptySquares(grid).length === 0) {\n//         res = DRAW;\n//         this.winningIndex = null;\n//       }\n//     });\n//     return res;\n//   };\n\n//   /**\n//    * Get the styles for strike through based on the combination that won\n//    */\n//   getStrikethroughStyles = () => {\n//     const defaultWidth = 285;\n//     const diagonalWidth = 400;\n//     switch (this.winningIndex) {\n//       case 0:\n//         return `\n//           transform: none;\n//           top: 41px;\n//           left: 15px;\n//           width: ${defaultWidth}px;\n//         `;\n//       case 1:\n//         return `\n//           transform: none;\n//           top: 140px;\n//           left: 15px;\n//           width: ${defaultWidth}px;\n//         `;\n//       case 2:\n//         return `\n//           transform: none;\n//           top: 242px;\n//           left: 15px;\n//           width: ${defaultWidth}px;\n//         `;\n//       case 3:\n//         return `\n//           transform: rotate(90deg);\n//           top: 145px;\n//           left: -86px;\n//           width: ${defaultWidth}px;\n//         `;\n//       case 4:\n//         return `\n//           transform: rotate(90deg);\n//           top: 145px;\n//           left: 15px;\n//           width: ${defaultWidth}px;\n//         `;\n//       case 5:\n//         return `\n//           transform: rotate(90deg);\n//           top: 145px;\n//           left: 115px;\n//           width: ${defaultWidth}px;\n//         `;\n//       case 6:\n//         return `\n//           transform: rotate(45deg);\n//           top: 145px;\n//           left: -44px;\n//           width: ${diagonalWidth}px;\n//         `;\n//       case 7:\n//         return `\n//           transform: rotate(-45deg);\n//           top: 145px;\n//           left: -46px;\n//           width: ${diagonalWidth}px;\n//         `;\n//       default:\n//         return null;\n//     }\n//   };\n\n//   clone = () => {\n//     return new Board(this.grid.concat());\n//   };\n// }\n// // minimax\n// export const minimax = (board, player) => {\n//   const mult = SCORES[String(player)];\n//   let thisScore;\n//   let maxScore = -1;\n//   let bestMove = null;\n\n//   if (board.getWinner() !== null) {\n//     return [SCORES[board.getWinner()], 0];\n//   } else {\n//     for (let empty of board.getEmptySquares()) {\n//       let copy = board.clone();\n//       copy.makeMove(empty, player);\n//       thisScore = mult * minimax(copy, switchPlayer(player))[0];\n\n//       if (thisScore >= maxScore) {\n//         maxScore = thisScore;\n//         bestMove = empty;\n//       }\n//     }\n\n//     return [mult * maxScore, bestMove];\n//   }\n// };\n\n// // utils\n// export const DIMS = 3;\n// export const DRAW = 0;\n// export const PLAYER_X = 1;\n// export const PLAYER_O = 2;\n// export const SCORES = {\n//   1: 1,\n//   0: 0,\n//   2: -1\n// };\n// export const SQUARE_DIMS = 100;\n// export const GAME_STATES = {\n//   notStarted: \"not_started\",\n//   inProgress: \"in_progress\",\n//   over: \"over\"\n// };\n\n// export const GAME_MODES = {\n//   easy: \"easy\",\n//   medium: \"medium\",\n//   difficult: \"difficult\"\n// };\n\n// export const switchPlayer = player => {\n//   return player === PLAYER_X ? PLAYER_O : PLAYER_X;\n// };\n\n// export const getRandomInt = (min, max) => {\n//   min = Math.ceil(min);\n//   max = Math.floor(max);\n//   return Math.floor(Math.random() * (max - min + 1)) + min;\n// };","map":{"version":3,"names":[],"sources":["C:/Users/olefi/OneDrive/Рабочий стол/tictactoereact/src/Board.js"],"sourcesContent":["// import { DIMS, DRAW } from \"./minimax\";\r\n\r\n// export default class Board {\r\n//   constructor(grid) {\r\n//     this.grid = grid || new Array(DIMS ** 2).fill(null);\r\n//     this.winningIndex = null;\r\n//   }\r\n\r\n//   makeMove = (square, player) => {\r\n//     if (this.grid[square] === null) {\r\n//       this.grid[square] = player;\r\n//     }\r\n//   };\r\n\r\n//   // Collect indices of empty squares and return them\r\n//   getEmptySquares = (grid = this.grid) => {\r\n//     let squares = [];\r\n//     grid.forEach((square, i) => {\r\n//       if (square === null) squares.push(i);\r\n//     });\r\n//     return squares;\r\n//   };\r\n\r\n//   isEmpty = (grid = this.grid) => {\r\n//     return this.getEmptySquares(grid).length === DIMS ** 2;\r\n//   };\r\n\r\n//   getWinner = (grid = this.grid) => {\r\n//     const winningCombos = [\r\n//       [0, 1, 2],\r\n//       [3, 4, 5],\r\n//       [6, 7, 8],\r\n//       [0, 3, 6],\r\n//       [1, 4, 7],\r\n//       [2, 5, 8],\r\n//       [0, 4, 8],\r\n//       [2, 4, 6]\r\n//     ];\r\n//     let res = null;\r\n//     winningCombos.forEach((el, i) => {\r\n//       if (\r\n//         grid[el[0]] !== null &&\r\n//         grid[el[0]] === grid[el[1]] &&\r\n//         grid[el[0]] === grid[el[2]]\r\n//       ) {\r\n//         res = grid[el[0]];\r\n//         this.winningIndex = i;\r\n//       } else if (res === null && this.getEmptySquares(grid).length === 0) {\r\n//         res = DRAW;\r\n//         this.winningIndex = null;\r\n//       }\r\n//     });\r\n//     return res;\r\n//   };\r\n\r\n//   /**\r\n//    * Get the styles for strike through based on the combination that won\r\n//    */\r\n//   getStrikethroughStyles = () => {\r\n//     const defaultWidth = 285;\r\n//     const diagonalWidth = 400;\r\n//     switch (this.winningIndex) {\r\n//       case 0:\r\n//         return `\r\n//           transform: none;\r\n//           top: 41px;\r\n//           left: 15px;\r\n//           width: ${defaultWidth}px;\r\n//         `;\r\n//       case 1:\r\n//         return `\r\n//           transform: none;\r\n//           top: 140px;\r\n//           left: 15px;\r\n//           width: ${defaultWidth}px;\r\n//         `;\r\n//       case 2:\r\n//         return `\r\n//           transform: none;\r\n//           top: 242px;\r\n//           left: 15px;\r\n//           width: ${defaultWidth}px;\r\n//         `;\r\n//       case 3:\r\n//         return `\r\n//           transform: rotate(90deg);\r\n//           top: 145px;\r\n//           left: -86px;\r\n//           width: ${defaultWidth}px;\r\n//         `;\r\n//       case 4:\r\n//         return `\r\n//           transform: rotate(90deg);\r\n//           top: 145px;\r\n//           left: 15px;\r\n//           width: ${defaultWidth}px;\r\n//         `;\r\n//       case 5:\r\n//         return `\r\n//           transform: rotate(90deg);\r\n//           top: 145px;\r\n//           left: 115px;\r\n//           width: ${defaultWidth}px;\r\n//         `;\r\n//       case 6:\r\n//         return `\r\n//           transform: rotate(45deg);\r\n//           top: 145px;\r\n//           left: -44px;\r\n//           width: ${diagonalWidth}px;\r\n//         `;\r\n//       case 7:\r\n//         return `\r\n//           transform: rotate(-45deg);\r\n//           top: 145px;\r\n//           left: -46px;\r\n//           width: ${diagonalWidth}px;\r\n//         `;\r\n//       default:\r\n//         return null;\r\n//     }\r\n//   };\r\n\r\n//   clone = () => {\r\n//     return new Board(this.grid.concat());\r\n//   };\r\n// }\r\n// // minimax\r\n// export const minimax = (board, player) => {\r\n//   const mult = SCORES[String(player)];\r\n//   let thisScore;\r\n//   let maxScore = -1;\r\n//   let bestMove = null;\r\n\r\n//   if (board.getWinner() !== null) {\r\n//     return [SCORES[board.getWinner()], 0];\r\n//   } else {\r\n//     for (let empty of board.getEmptySquares()) {\r\n//       let copy = board.clone();\r\n//       copy.makeMove(empty, player);\r\n//       thisScore = mult * minimax(copy, switchPlayer(player))[0];\r\n\r\n//       if (thisScore >= maxScore) {\r\n//         maxScore = thisScore;\r\n//         bestMove = empty;\r\n//       }\r\n//     }\r\n\r\n//     return [mult * maxScore, bestMove];\r\n//   }\r\n// };\r\n\r\n// // utils\r\n// export const DIMS = 3;\r\n// export const DRAW = 0;\r\n// export const PLAYER_X = 1;\r\n// export const PLAYER_O = 2;\r\n// export const SCORES = {\r\n//   1: 1,\r\n//   0: 0,\r\n//   2: -1\r\n// };\r\n// export const SQUARE_DIMS = 100;\r\n// export const GAME_STATES = {\r\n//   notStarted: \"not_started\",\r\n//   inProgress: \"in_progress\",\r\n//   over: \"over\"\r\n// };\r\n\r\n// export const GAME_MODES = {\r\n//   easy: \"easy\",\r\n//   medium: \"medium\",\r\n//   difficult: \"difficult\"\r\n// };\r\n\r\n// export const switchPlayer = player => {\r\n//   return player === PLAYER_X ? PLAYER_O : PLAYER_X;\r\n// };\r\n\r\n// export const getRandomInt = (min, max) => {\r\n//   min = Math.ceil(min);\r\n//   max = Math.floor(max);\r\n//   return Math.floor(Math.random() * (max - min + 1)) + min;\r\n// };\r\n\r\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}