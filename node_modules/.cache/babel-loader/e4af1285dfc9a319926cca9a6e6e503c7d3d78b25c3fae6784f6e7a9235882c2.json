{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\olefi\\\\OneDrive\\\\\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B\\\\tictactoereact\\\\src\\\\AI.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback } from \"react\";\nimport styled from \"styled-components\";\nimport Board from \"./AiBoard\";\nimport { ResultModal } from \"./ResultModal\";\nimport { border } from \"./styles\";\nimport { PLAYER_X, PLAYER_O, SQUARE_DIMS, DRAW, GAME_STATES, DIMS, GAME_MODES,\n// Board,\ngetRandomInt, switchPlayer, minimax } from \"./AiBoard\";\n// import Board from \"./AiBoard\";\n// import { ResultModal } from \"./ResultModal\";\n// import { border } from \"./styles\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst arr = new Array(DIMS ** 2).fill(null);\nconst board = new Board();\nconst TicTacToe = _ref => {\n  _s();\n  let {\n    squares = arr\n  } = _ref;\n  const [players, setPlayers] = useState({\n    human: null,\n    computer: null\n  });\n  const [gameState, setGameState] = useState(GAME_STATES.notStarted);\n  const [grid, setGrid] = useState(squares);\n  const [winner, setWinner] = useState(null);\n  const [nextMove, setNextMove] = useState(null);\n  const [modalOpen, setModalOpen] = useState(false);\n  const [mode, setMode] = useState(GAME_MODES.medium);\n\n  /**\r\n   * On every move, check if there is a winner. If yes, set game state to over and open result modal\r\n   */\n  useEffect(() => {\n    const winner = board.getWinner(grid);\n    const declareWinner = winner => {\n      let winnerStr;\n      switch (winner) {\n        case PLAYER_X:\n          winnerStr = \"Player X wins!\";\n          break;\n        case PLAYER_O:\n          winnerStr = \"Player O wins!\";\n          break;\n        case DRAW:\n        default:\n          winnerStr = \"It's a draw\";\n      }\n      setGameState(GAME_STATES.over);\n      setWinner(winnerStr);\n      // Slight delay for the modal so there is some time to see the last move\n      setTimeout(() => setModalOpen(true), 300);\n    };\n    if (winner !== null && gameState !== GAME_STATES.over) {\n      declareWinner(winner);\n    }\n  }, [gameState, grid, nextMove]);\n\n  /**\r\n   * Set the grid square with respective player that made the move. Only make a move when the game is in progress.\r\n   * useCallback is necessary to prevent unnecessary recreation of the function, unless gameState changes, since it is\r\n   * being tracked in useEffect\r\n   * @type {Function}\r\n   */\n  const move = useCallback((index, player) => {\n    if (player && gameState === GAME_STATES.inProgress) {\n      setGrid(grid => {\n        const gridCopy = grid.concat();\n        gridCopy[index] = player;\n        return gridCopy;\n      });\n    }\n  }, [gameState]);\n\n  /**\r\n   * Make computer move. If it's the first move (board is empty), make move at any random cell to skip\r\n   * unnecessary minimax calculations\r\n   * @type {Function}\r\n   */\n  const computerMove = useCallback(() => {\n    // Important to pass a copy of the grid here\n    const board = new Board(grid.concat());\n    const emptyIndices = board.getEmptySquares(grid);\n    let index;\n    switch (mode) {\n      case GAME_MODES.easy:\n        do {\n          index = getRandomInt(0, 8);\n        } while (!emptyIndices.includes(index));\n        break;\n      case GAME_MODES.medium:\n        // Medium level is basically ~half of the moves are minimax and the other ~half random\n        const smartMove = !board.isEmpty(grid) && Math.random() < 0.5;\n        if (smartMove) {\n          index = minimax(board, players.computer)[1];\n        } else {\n          do {\n            index = getRandomInt(0, 8);\n          } while (!emptyIndices.includes(index));\n        }\n        break;\n      case GAME_MODES.difficult:\n      default:\n        index = board.isEmpty(grid) ? getRandomInt(0, 8) : minimax(board, players.computer)[1];\n    }\n    if (!grid[index]) {\n      move(index, players.computer);\n      setNextMove(players.human);\n    }\n  }, [move, grid, players, mode]);\n\n  /**\r\n   * Make computer move when it's computer's turn\r\n   */\n  useEffect(() => {\n    let timeout;\n    if (nextMove !== null && nextMove === players.computer && gameState !== GAME_STATES.over) {\n      // Delay computer moves to make them more natural\n      timeout = setTimeout(() => {\n        computerMove();\n      }, 500);\n    }\n    return () => timeout && clearTimeout(timeout);\n  }, [nextMove, computerMove, players.computer, gameState]);\n  const humanMove = index => {\n    if (!grid[index] && nextMove === players.human) {\n      move(index, players.human);\n      setNextMove(players.computer);\n    }\n  };\n  const choosePlayer = option => {\n    setPlayers({\n      human: option,\n      computer: switchPlayer(option)\n    });\n    setGameState(GAME_STATES.inProgress);\n    setNextMove(PLAYER_X);\n  };\n  const startNewGame = () => {\n    setGameState(GAME_STATES.notStarted);\n    setGrid(arr);\n    setModalOpen(false);\n  };\n  const changeMode = e => {\n    setMode(e.target.value);\n  };\n  return gameState === GAME_STATES.notStarted ? /*#__PURE__*/_jsxDEV(Screen, {\n    children: [/*#__PURE__*/_jsxDEV(Inner, {\n      children: [/*#__PURE__*/_jsxDEV(ChooseText, {\n        children: \"Select difficulty\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 166,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"select\", {\n        onChange: changeMode,\n        value: mode,\n        children: Object.keys(GAME_MODES).map(key => {\n          const gameMode = GAME_MODES[key];\n          return /*#__PURE__*/_jsxDEV(\"option\", {\n            value: gameMode,\n            children: key\n          }, gameMode, false, {\n            fileName: _jsxFileName,\n            lineNumber: 171,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 167,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Inner, {\n      children: [/*#__PURE__*/_jsxDEV(ChooseText, {\n        children: \"Choose your player\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 179,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonRow, {\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => choosePlayer(PLAYER_X),\n          children: \"X\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 181,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"or\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 182,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => choosePlayer(PLAYER_O),\n          children: \"O\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 183,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 180,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 178,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 164,\n    columnNumber: 5\n  }, this) : /*#__PURE__*/_jsxDEV(Container, {\n    dims: DIMS,\n    children: [grid.map((value, index) => {\n      const isActive = value !== null;\n      return /*#__PURE__*/_jsxDEV(Square, {\n        \"data-testid\": `square_${index}`,\n        onClick: () => humanMove(index),\n        children: isActive && /*#__PURE__*/_jsxDEV(Marker, {\n          children: value === PLAYER_X ? \"X\" : \"O\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 198,\n          columnNumber: 26\n        }, this)\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 193,\n        columnNumber: 11\n      }, this);\n    }), /*#__PURE__*/_jsxDEV(Strikethrough, {\n      styles: gameState === GAME_STATES.over && board.getStrikethroughStyles()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 202,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ResultModal, {\n      isOpen: modalOpen,\n      winner: winner,\n      close: () => setModalOpen(false),\n      startNewGame: startNewGame\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 207,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 188,\n    columnNumber: 5\n  }, this);\n};\n_s(TicTacToe, \"WCjgt3syk0+/ASjw6JZBXoi5+9k=\");\n_c = TicTacToe;\nconst Container = styled.div`\n  display: flex;\n  justify-content: center;\n  width: ${_ref2 => {\n  let {\n    dims\n  } = _ref2;\n  return `${dims * (SQUARE_DIMS + 5)}px`;\n}};\n  flex-flow: wrap;\n  position: relative;\n`;\n_c2 = Container;\nconst Square = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: ${SQUARE_DIMS}px;\n  height: ${SQUARE_DIMS}px;\n  ${border};\n\n  &:hover {\n    cursor: pointer;\n  }\n`;\n_c3 = Square;\nSquare.displayName = \"Square\";\nconst Marker = styled.p`\n  font-size: 68px;\n`;\n_c4 = Marker;\nconst ButtonRow = styled.div`\n  display: flex;\n  width: 150px;\n  justify-content: space-between;\n`;\n_c5 = ButtonRow;\nconst Screen = styled.div``;\n_c6 = Screen;\nconst Inner = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-bottom: 30px;\n`;\n_c7 = Inner;\nconst ChooseText = styled.p``;\n_c8 = ChooseText;\nconst Strikethrough = styled.div`\n  position: absolute;\n  ${_ref3 => {\n  let {\n    styles\n  } = _ref3;\n  return styles;\n}}\n  background-color: indianred;\n  height: 5px;\n  width: ${_ref4 => {\n  let {\n    styles\n  } = _ref4;\n  return !styles && \"0px\";\n}};\n`;\n_c9 = Strikethrough;\nexport default TicTacToe;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9;\n$RefreshReg$(_c, \"TicTacToe\");\n$RefreshReg$(_c2, \"Container\");\n$RefreshReg$(_c3, \"Square\");\n$RefreshReg$(_c4, \"Marker\");\n$RefreshReg$(_c5, \"ButtonRow\");\n$RefreshReg$(_c6, \"Screen\");\n$RefreshReg$(_c7, \"Inner\");\n$RefreshReg$(_c8, \"ChooseText\");\n$RefreshReg$(_c9, \"Strikethrough\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","styled","Board","ResultModal","border","PLAYER_X","PLAYER_O","SQUARE_DIMS","DRAW","GAME_STATES","DIMS","GAME_MODES","getRandomInt","switchPlayer","minimax","arr","Array","fill","board","TicTacToe","squares","players","setPlayers","human","computer","gameState","setGameState","notStarted","grid","setGrid","winner","setWinner","nextMove","setNextMove","modalOpen","setModalOpen","mode","setMode","medium","getWinner","declareWinner","winnerStr","over","setTimeout","move","index","player","inProgress","gridCopy","concat","computerMove","emptyIndices","getEmptySquares","easy","includes","smartMove","isEmpty","Math","random","difficult","timeout","clearTimeout","humanMove","choosePlayer","option","startNewGame","changeMode","e","target","value","Object","keys","map","key","gameMode","isActive","getStrikethroughStyles","Container","div","dims","Square","displayName","Marker","p","ButtonRow","Screen","Inner","ChooseText","Strikethrough","styles"],"sources":["C:/Users/olefi/OneDrive/Рабочий стол/tictactoereact/src/AI.js"],"sourcesContent":["import React, { useState, useEffect, useCallback } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport Board from \"./AiBoard\";\r\nimport { ResultModal } from \"./ResultModal\";\r\nimport { border } from \"./styles\";\r\nimport {\r\n  PLAYER_X,\r\n  PLAYER_O,\r\n  SQUARE_DIMS,\r\n  DRAW,\r\n  GAME_STATES,\r\n  DIMS,\r\n  GAME_MODES,\r\n  // Board,\r\n  getRandomInt,\r\n  switchPlayer,\r\n  minimax\r\n} from \"./AiBoard\";\r\n// import Board from \"./AiBoard\";\r\n// import { ResultModal } from \"./ResultModal\";\r\n// import { border } from \"./styles\";\r\n\r\nconst arr = new Array(DIMS ** 2).fill(null);\r\nconst board = new Board();\r\n\r\nconst TicTacToe = ({ squares = arr }) => {\r\n  const [players, setPlayers] = useState({ human: null, computer: null });\r\n  const [gameState, setGameState] = useState(GAME_STATES.notStarted);\r\n  const [grid, setGrid] = useState(squares);\r\n  const [winner, setWinner] = useState(null);\r\n  const [nextMove, setNextMove] = useState(null);\r\n  const [modalOpen, setModalOpen] = useState(false);\r\n  const [mode, setMode] = useState(GAME_MODES.medium);\r\n\r\n  /**\r\n   * On every move, check if there is a winner. If yes, set game state to over and open result modal\r\n   */\r\n  useEffect(() => {\r\n    const winner = board.getWinner(grid);\r\n    const declareWinner = winner => {\r\n      let winnerStr;\r\n      switch (winner) {\r\n        case PLAYER_X:\r\n          winnerStr = \"Player X wins!\";\r\n          break;\r\n        case PLAYER_O:\r\n          winnerStr = \"Player O wins!\";\r\n          break;\r\n        case DRAW:\r\n        default:\r\n          winnerStr = \"It's a draw\";\r\n      }\r\n      setGameState(GAME_STATES.over);\r\n      setWinner(winnerStr);\r\n      // Slight delay for the modal so there is some time to see the last move\r\n      setTimeout(() => setModalOpen(true), 300);\r\n    };\r\n\r\n    if (winner !== null && gameState !== GAME_STATES.over) {\r\n      declareWinner(winner);\r\n    }\r\n  }, [gameState, grid, nextMove]);\r\n\r\n  /**\r\n   * Set the grid square with respective player that made the move. Only make a move when the game is in progress.\r\n   * useCallback is necessary to prevent unnecessary recreation of the function, unless gameState changes, since it is\r\n   * being tracked in useEffect\r\n   * @type {Function}\r\n   */\r\n  const move = useCallback(\r\n    (index, player) => {\r\n      if (player && gameState === GAME_STATES.inProgress) {\r\n        setGrid(grid => {\r\n          const gridCopy = grid.concat();\r\n          gridCopy[index] = player;\r\n          return gridCopy;\r\n        });\r\n      }\r\n    },\r\n    [gameState]\r\n  );\r\n\r\n  /**\r\n   * Make computer move. If it's the first move (board is empty), make move at any random cell to skip\r\n   * unnecessary minimax calculations\r\n   * @type {Function}\r\n   */\r\n  const computerMove = useCallback(() => {\r\n    // Important to pass a copy of the grid here\r\n    const board = new Board(grid.concat());\r\n    const emptyIndices = board.getEmptySquares(grid);\r\n    let index;\r\n    switch (mode) {\r\n      case GAME_MODES.easy:\r\n        do {\r\n          index = getRandomInt(0, 8);\r\n        } while (!emptyIndices.includes(index));\r\n        break;\r\n      case GAME_MODES.medium:\r\n        // Medium level is basically ~half of the moves are minimax and the other ~half random\r\n        const smartMove = !board.isEmpty(grid) && Math.random() < 0.5;\r\n        if (smartMove) {\r\n          index = minimax(board, players.computer)[1];\r\n        } else {\r\n          do {\r\n            index = getRandomInt(0, 8);\r\n          } while (!emptyIndices.includes(index));\r\n        }\r\n        break;\r\n      case GAME_MODES.difficult:\r\n      default:\r\n        index = board.isEmpty(grid)\r\n          ? getRandomInt(0, 8)\r\n          : minimax(board, players.computer)[1];\r\n    }\r\n    if (!grid[index]) {\r\n      move(index, players.computer);\r\n      setNextMove(players.human);\r\n    }\r\n  }, [move, grid, players, mode]);\r\n\r\n  /**\r\n   * Make computer move when it's computer's turn\r\n   */\r\n  useEffect(() => {\r\n    let timeout;\r\n    if (\r\n      nextMove !== null &&\r\n      nextMove === players.computer &&\r\n      gameState !== GAME_STATES.over\r\n    ) {\r\n      // Delay computer moves to make them more natural\r\n      timeout = setTimeout(() => {\r\n        computerMove();\r\n      }, 500);\r\n    }\r\n    return () => timeout && clearTimeout(timeout);\r\n  }, [nextMove, computerMove, players.computer, gameState]);\r\n\r\n  const humanMove = index => {\r\n    if (!grid[index] && nextMove === players.human) {\r\n      move(index, players.human);\r\n      setNextMove(players.computer);\r\n    }\r\n  };\r\n\r\n  const choosePlayer = option => {\r\n    setPlayers({ human: option, computer: switchPlayer(option) });\r\n    setGameState(GAME_STATES.inProgress);\r\n    setNextMove(PLAYER_X);\r\n  };\r\n\r\n  const startNewGame = () => {\r\n    setGameState(GAME_STATES.notStarted);\r\n    setGrid(arr);\r\n    setModalOpen(false);\r\n  };\r\n\r\n  const changeMode = e => {\r\n    setMode(e.target.value);\r\n  };\r\n\r\n  return gameState === GAME_STATES.notStarted ? (\r\n    <Screen>\r\n      <Inner>\r\n        <ChooseText>Select difficulty</ChooseText>\r\n        <select onChange={changeMode} value={mode}>\r\n          {Object.keys(GAME_MODES).map(key => {\r\n            const gameMode = GAME_MODES[key];\r\n            return (\r\n              <option key={gameMode} value={gameMode}>\r\n                {key}\r\n              </option>\r\n            );\r\n          })}\r\n        </select>\r\n      </Inner>\r\n      <Inner>\r\n        <ChooseText>Choose your player</ChooseText>\r\n        <ButtonRow>\r\n          <button onClick={() => choosePlayer(PLAYER_X)}>X</button>\r\n          <p>or</p>\r\n          <button onClick={() => choosePlayer(PLAYER_O)}>O</button>\r\n        </ButtonRow>\r\n      </Inner>\r\n    </Screen>\r\n  ) : (\r\n    <Container dims={DIMS}>\r\n      {grid.map((value, index) => {\r\n        const isActive = value !== null;\r\n\r\n        return (\r\n          <Square\r\n            data-testid={`square_${index}`}\r\n            key={index}\r\n            onClick={() => humanMove(index)}\r\n          >\r\n            {isActive && <Marker>{value === PLAYER_X ? \"X\" : \"O\"}</Marker>}\r\n          </Square>\r\n        );\r\n      })}\r\n      <Strikethrough\r\n        styles={\r\n          gameState === GAME_STATES.over && board.getStrikethroughStyles()\r\n        }\r\n      />\r\n      <ResultModal\r\n        isOpen={modalOpen}\r\n        winner={winner}\r\n        close={() => setModalOpen(false)}\r\n        startNewGame={startNewGame}\r\n      />\r\n    </Container>\r\n  );\r\n};\r\n\r\nconst Container = styled.div`\r\n  display: flex;\r\n  justify-content: center;\r\n  width: ${({ dims }) => `${dims * (SQUARE_DIMS + 5)}px`};\r\n  flex-flow: wrap;\r\n  position: relative;\r\n`;\r\n\r\nconst Square = styled.div`\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  width: ${SQUARE_DIMS}px;\r\n  height: ${SQUARE_DIMS}px;\r\n  ${border};\r\n\r\n  &:hover {\r\n    cursor: pointer;\r\n  }\r\n`;\r\n\r\nSquare.displayName = \"Square\";\r\n\r\nconst Marker = styled.p`\r\n  font-size: 68px;\r\n`;\r\n\r\nconst ButtonRow = styled.div`\r\n  display: flex;\r\n  width: 150px;\r\n  justify-content: space-between;\r\n`;\r\n\r\nconst Screen = styled.div``;\r\n\r\nconst Inner = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  margin-bottom: 30px;\r\n`;\r\nconst ChooseText = styled.p``;\r\n\r\nconst Strikethrough = styled.div`\r\n  position: absolute;\r\n  ${({ styles }) => styles}\r\n  background-color: indianred;\r\n  height: 5px;\r\n  width: ${({ styles }) => !styles && \"0px\"};\r\n`;\r\n\r\nexport default TicTacToe;\r\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AAC/D,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,KAAK,MAAM,WAAW;AAC7B,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,MAAM,QAAQ,UAAU;AACjC,SACEC,QAAQ,EACRC,QAAQ,EACRC,WAAW,EACXC,IAAI,EACJC,WAAW,EACXC,IAAI,EACJC,UAAU;AACV;AACAC,YAAY,EACZC,YAAY,EACZC,OAAO,QACF,WAAW;AAClB;AACA;AACA;AAAA;AAEA,MAAMC,GAAG,GAAG,IAAIC,KAAK,CAACN,IAAI,IAAI,CAAC,CAAC,CAACO,IAAI,CAAC,IAAI,CAAC;AAC3C,MAAMC,KAAK,GAAG,IAAIhB,KAAK,EAAE;AAEzB,MAAMiB,SAAS,GAAG,QAAuB;EAAA;EAAA,IAAtB;IAAEC,OAAO,GAAGL;EAAI,CAAC;EAClC,MAAM,CAACM,OAAO,EAAEC,UAAU,CAAC,GAAGxB,QAAQ,CAAC;IAAEyB,KAAK,EAAE,IAAI;IAAEC,QAAQ,EAAE;EAAK,CAAC,CAAC;EACvE,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAG5B,QAAQ,CAACW,WAAW,CAACkB,UAAU,CAAC;EAClE,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAG/B,QAAQ,CAACsB,OAAO,CAAC;EACzC,MAAM,CAACU,MAAM,EAAEC,SAAS,CAAC,GAAGjC,QAAQ,CAAC,IAAI,CAAC;EAC1C,MAAM,CAACkC,QAAQ,EAAEC,WAAW,CAAC,GAAGnC,QAAQ,CAAC,IAAI,CAAC;EAC9C,MAAM,CAACoC,SAAS,EAAEC,YAAY,CAAC,GAAGrC,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACsC,IAAI,EAAEC,OAAO,CAAC,GAAGvC,QAAQ,CAACa,UAAU,CAAC2B,MAAM,CAAC;;EAEnD;AACF;AACA;EACEvC,SAAS,CAAC,MAAM;IACd,MAAM+B,MAAM,GAAGZ,KAAK,CAACqB,SAAS,CAACX,IAAI,CAAC;IACpC,MAAMY,aAAa,GAAGV,MAAM,IAAI;MAC9B,IAAIW,SAAS;MACb,QAAQX,MAAM;QACZ,KAAKzB,QAAQ;UACXoC,SAAS,GAAG,gBAAgB;UAC5B;QACF,KAAKnC,QAAQ;UACXmC,SAAS,GAAG,gBAAgB;UAC5B;QACF,KAAKjC,IAAI;QACT;UACEiC,SAAS,GAAG,aAAa;MAAC;MAE9Bf,YAAY,CAACjB,WAAW,CAACiC,IAAI,CAAC;MAC9BX,SAAS,CAACU,SAAS,CAAC;MACpB;MACAE,UAAU,CAAC,MAAMR,YAAY,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC;IAC3C,CAAC;IAED,IAAIL,MAAM,KAAK,IAAI,IAAIL,SAAS,KAAKhB,WAAW,CAACiC,IAAI,EAAE;MACrDF,aAAa,CAACV,MAAM,CAAC;IACvB;EACF,CAAC,EAAE,CAACL,SAAS,EAAEG,IAAI,EAAEI,QAAQ,CAAC,CAAC;;EAE/B;AACF;AACA;AACA;AACA;AACA;EACE,MAAMY,IAAI,GAAG5C,WAAW,CACtB,CAAC6C,KAAK,EAAEC,MAAM,KAAK;IACjB,IAAIA,MAAM,IAAIrB,SAAS,KAAKhB,WAAW,CAACsC,UAAU,EAAE;MAClDlB,OAAO,CAACD,IAAI,IAAI;QACd,MAAMoB,QAAQ,GAAGpB,IAAI,CAACqB,MAAM,EAAE;QAC9BD,QAAQ,CAACH,KAAK,CAAC,GAAGC,MAAM;QACxB,OAAOE,QAAQ;MACjB,CAAC,CAAC;IACJ;EACF,CAAC,EACD,CAACvB,SAAS,CAAC,CACZ;;EAED;AACF;AACA;AACA;AACA;EACE,MAAMyB,YAAY,GAAGlD,WAAW,CAAC,MAAM;IACrC;IACA,MAAMkB,KAAK,GAAG,IAAIhB,KAAK,CAAC0B,IAAI,CAACqB,MAAM,EAAE,CAAC;IACtC,MAAME,YAAY,GAAGjC,KAAK,CAACkC,eAAe,CAACxB,IAAI,CAAC;IAChD,IAAIiB,KAAK;IACT,QAAQT,IAAI;MACV,KAAKzB,UAAU,CAAC0C,IAAI;QAClB,GAAG;UACDR,KAAK,GAAGjC,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC;QAC5B,CAAC,QAAQ,CAACuC,YAAY,CAACG,QAAQ,CAACT,KAAK,CAAC;QACtC;MACF,KAAKlC,UAAU,CAAC2B,MAAM;QACpB;QACA,MAAMiB,SAAS,GAAG,CAACrC,KAAK,CAACsC,OAAO,CAAC5B,IAAI,CAAC,IAAI6B,IAAI,CAACC,MAAM,EAAE,GAAG,GAAG;QAC7D,IAAIH,SAAS,EAAE;UACbV,KAAK,GAAG/B,OAAO,CAACI,KAAK,EAAEG,OAAO,CAACG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC7C,CAAC,MAAM;UACL,GAAG;YACDqB,KAAK,GAAGjC,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC;UAC5B,CAAC,QAAQ,CAACuC,YAAY,CAACG,QAAQ,CAACT,KAAK,CAAC;QACxC;QACA;MACF,KAAKlC,UAAU,CAACgD,SAAS;MACzB;QACEd,KAAK,GAAG3B,KAAK,CAACsC,OAAO,CAAC5B,IAAI,CAAC,GACvBhB,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,GAClBE,OAAO,CAACI,KAAK,EAAEG,OAAO,CAACG,QAAQ,CAAC,CAAC,CAAC,CAAC;IAAC;IAE5C,IAAI,CAACI,IAAI,CAACiB,KAAK,CAAC,EAAE;MAChBD,IAAI,CAACC,KAAK,EAAExB,OAAO,CAACG,QAAQ,CAAC;MAC7BS,WAAW,CAACZ,OAAO,CAACE,KAAK,CAAC;IAC5B;EACF,CAAC,EAAE,CAACqB,IAAI,EAAEhB,IAAI,EAAEP,OAAO,EAAEe,IAAI,CAAC,CAAC;;EAE/B;AACF;AACA;EACErC,SAAS,CAAC,MAAM;IACd,IAAI6D,OAAO;IACX,IACE5B,QAAQ,KAAK,IAAI,IACjBA,QAAQ,KAAKX,OAAO,CAACG,QAAQ,IAC7BC,SAAS,KAAKhB,WAAW,CAACiC,IAAI,EAC9B;MACA;MACAkB,OAAO,GAAGjB,UAAU,CAAC,MAAM;QACzBO,YAAY,EAAE;MAChB,CAAC,EAAE,GAAG,CAAC;IACT;IACA,OAAO,MAAMU,OAAO,IAAIC,YAAY,CAACD,OAAO,CAAC;EAC/C,CAAC,EAAE,CAAC5B,QAAQ,EAAEkB,YAAY,EAAE7B,OAAO,CAACG,QAAQ,EAAEC,SAAS,CAAC,CAAC;EAEzD,MAAMqC,SAAS,GAAGjB,KAAK,IAAI;IACzB,IAAI,CAACjB,IAAI,CAACiB,KAAK,CAAC,IAAIb,QAAQ,KAAKX,OAAO,CAACE,KAAK,EAAE;MAC9CqB,IAAI,CAACC,KAAK,EAAExB,OAAO,CAACE,KAAK,CAAC;MAC1BU,WAAW,CAACZ,OAAO,CAACG,QAAQ,CAAC;IAC/B;EACF,CAAC;EAED,MAAMuC,YAAY,GAAGC,MAAM,IAAI;IAC7B1C,UAAU,CAAC;MAAEC,KAAK,EAAEyC,MAAM;MAAExC,QAAQ,EAAEX,YAAY,CAACmD,MAAM;IAAE,CAAC,CAAC;IAC7DtC,YAAY,CAACjB,WAAW,CAACsC,UAAU,CAAC;IACpCd,WAAW,CAAC5B,QAAQ,CAAC;EACvB,CAAC;EAED,MAAM4D,YAAY,GAAG,MAAM;IACzBvC,YAAY,CAACjB,WAAW,CAACkB,UAAU,CAAC;IACpCE,OAAO,CAACd,GAAG,CAAC;IACZoB,YAAY,CAAC,KAAK,CAAC;EACrB,CAAC;EAED,MAAM+B,UAAU,GAAGC,CAAC,IAAI;IACtB9B,OAAO,CAAC8B,CAAC,CAACC,MAAM,CAACC,KAAK,CAAC;EACzB,CAAC;EAED,OAAO5C,SAAS,KAAKhB,WAAW,CAACkB,UAAU,gBACzC,QAAC,MAAM;IAAA,wBACL,QAAC,KAAK;MAAA,wBACJ,QAAC,UAAU;QAAA,UAAC;MAAiB;QAAA;QAAA;QAAA;MAAA,QAAa,eAC1C;QAAQ,QAAQ,EAAEuC,UAAW;QAAC,KAAK,EAAE9B,IAAK;QAAA,UACvCkC,MAAM,CAACC,IAAI,CAAC5D,UAAU,CAAC,CAAC6D,GAAG,CAACC,GAAG,IAAI;UAClC,MAAMC,QAAQ,GAAG/D,UAAU,CAAC8D,GAAG,CAAC;UAChC,oBACE;YAAuB,KAAK,EAAEC,QAAS;YAAA,UACpCD;UAAG,GADOC,QAAQ;YAAA;YAAA;YAAA;UAAA,QAEZ;QAEb,CAAC;MAAC;QAAA;QAAA;QAAA;MAAA,QACK;IAAA;MAAA;MAAA;MAAA;IAAA,QACH,eACR,QAAC,KAAK;MAAA,wBACJ,QAAC,UAAU;QAAA,UAAC;MAAkB;QAAA;QAAA;QAAA;MAAA,QAAa,eAC3C,QAAC,SAAS;QAAA,wBACR;UAAQ,OAAO,EAAE,MAAMX,YAAY,CAAC1D,QAAQ,CAAE;UAAA,UAAC;QAAC;UAAA;UAAA;UAAA;QAAA,QAAS,eACzD;UAAA,UAAG;QAAE;UAAA;UAAA;UAAA;QAAA,QAAI,eACT;UAAQ,OAAO,EAAE,MAAM0D,YAAY,CAACzD,QAAQ,CAAE;UAAA,UAAC;QAAC;UAAA;UAAA;UAAA;QAAA,QAAS;MAAA;QAAA;QAAA;QAAA;MAAA,QAC/C;IAAA;MAAA;MAAA;MAAA;IAAA,QACN;EAAA;IAAA;IAAA;IAAA;EAAA,QACD,gBAET,QAAC,SAAS;IAAC,IAAI,EAAEI,IAAK;IAAA,WACnBkB,IAAI,CAAC4C,GAAG,CAAC,CAACH,KAAK,EAAExB,KAAK,KAAK;MAC1B,MAAM8B,QAAQ,GAAGN,KAAK,KAAK,IAAI;MAE/B,oBACE,QAAC,MAAM;QACL,eAAc,UAASxB,KAAM,EAAE;QAE/B,OAAO,EAAE,MAAMiB,SAAS,CAACjB,KAAK,CAAE;QAAA,UAE/B8B,QAAQ,iBAAI,QAAC,MAAM;UAAA,UAAEN,KAAK,KAAKhE,QAAQ,GAAG,GAAG,GAAG;QAAG;UAAA;UAAA;UAAA;QAAA;MAAU,GAHzDwC,KAAK;QAAA;QAAA;QAAA;MAAA,QAIH;IAEb,CAAC,CAAC,eACF,QAAC,aAAa;MACZ,MAAM,EACJpB,SAAS,KAAKhB,WAAW,CAACiC,IAAI,IAAIxB,KAAK,CAAC0D,sBAAsB;IAC/D;MAAA;MAAA;MAAA;IAAA,QACD,eACF,QAAC,WAAW;MACV,MAAM,EAAE1C,SAAU;MAClB,MAAM,EAAEJ,MAAO;MACf,KAAK,EAAE,MAAMK,YAAY,CAAC,KAAK,CAAE;MACjC,YAAY,EAAE8B;IAAa;MAAA;MAAA;MAAA;IAAA,QAC3B;EAAA;IAAA;IAAA;IAAA;EAAA,QAEL;AACH,CAAC;AAAC,GA7LI9C,SAAS;AAAA,KAATA,SAAS;AA+Lf,MAAM0D,SAAS,GAAG5E,MAAM,CAAC6E,GAAI;AAC7B;AACA;AACA,WAAW;EAAA,IAAC;IAAEC;EAAK,CAAC;EAAA,OAAM,GAAEA,IAAI,IAAIxE,WAAW,GAAG,CAAC,CAAE,IAAG;AAAA,CAAC;AACzD;AACA;AACA,CAAC;AAAC,MANIsE,SAAS;AAQf,MAAMG,MAAM,GAAG/E,MAAM,CAAC6E,GAAI;AAC1B;AACA;AACA;AACA,WAAWvE,WAAY;AACvB,YAAYA,WAAY;AACxB,IAAIH,MAAO;AACX;AACA;AACA;AACA;AACA,CAAC;AAAC,MAXI4E,MAAM;AAaZA,MAAM,CAACC,WAAW,GAAG,QAAQ;AAE7B,MAAMC,MAAM,GAAGjF,MAAM,CAACkF,CAAE;AACxB;AACA,CAAC;AAAC,MAFID,MAAM;AAIZ,MAAME,SAAS,GAAGnF,MAAM,CAAC6E,GAAI;AAC7B;AACA;AACA;AACA,CAAC;AAAC,MAJIM,SAAS;AAMf,MAAMC,MAAM,GAAGpF,MAAM,CAAC6E,GAAI,EAAC;AAAC,MAAtBO,MAAM;AAEZ,MAAMC,KAAK,GAAGrF,MAAM,CAAC6E,GAAI;AACzB;AACA;AACA;AACA;AACA,CAAC;AAAC,MALIQ,KAAK;AAMX,MAAMC,UAAU,GAAGtF,MAAM,CAACkF,CAAE,EAAC;AAAC,MAAxBI,UAAU;AAEhB,MAAMC,aAAa,GAAGvF,MAAM,CAAC6E,GAAI;AACjC;AACA,IAAI;EAAA,IAAC;IAAEW;EAAO,CAAC;EAAA,OAAKA,MAAM;AAAA,CAAC;AAC3B;AACA;AACA,WAAW;EAAA,IAAC;IAAEA;EAAO,CAAC;EAAA,OAAK,CAACA,MAAM,IAAI,KAAK;AAAA,CAAC;AAC5C,CAAC;AAAC,MANID,aAAa;AAQnB,eAAerE,SAAS;AAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}