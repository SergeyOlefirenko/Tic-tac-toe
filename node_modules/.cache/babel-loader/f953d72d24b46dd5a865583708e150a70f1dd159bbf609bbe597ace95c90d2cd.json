{"ast":null,"code":"export default class Board {\n  constructor(_grid) {\n    var _this = this;\n    this.makeMove = (square, player) => {\n      if (this.grid[square] === null) {\n        this.grid[square] = player;\n      }\n    };\n    this.getEmptySquares = function () {\n      let grid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.grid;\n      let squares = [];\n      grid.forEach((square, i) => {\n        if (square === null) squares.push(i);\n      });\n      return squares;\n    };\n    this.isEmpty = function () {\n      let grid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.grid;\n      return _this.getEmptySquares(grid).length === DIMS ** 2;\n    };\n    this.getWinner = function () {\n      let grid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.grid;\n      const winningCombos = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];\n      let res = null;\n      winningCombos.forEach((el, i) => {\n        if (grid[el[0]] !== null && grid[el[0]] === grid[el[1]] && grid[el[0]] === grid[el[2]]) {\n          res = grid[el[0]];\n          _this.winningIndex = i;\n        } else if (res === null && _this.getEmptySquares(grid).length === 0) {\n          res = DRAW;\n          _this.winningIndex = null;\n        }\n      });\n      return res;\n    };\n    this.getStrikethroughStyles = () => {\n      const defaultWidth = 285;\n      const diagonalWidth = 400;\n      switch (this.winningIndex) {\n        case 0:\n          return `\n          // transform: none;\n          // top: 61px;\n          // left: 15px;\n          width: ${defaultWidth}px;\n        `;\n        case 1:\n          return `\n          // transform: none;\n          // top: 140px;\n          // left: 15px;\n          width: ${defaultWidth}px;\n        `;\n        case 2:\n          return `\n          // transform: none;\n          // top: 242px;\n          // left: 15px;\n          width: ${defaultWidth}px;\n        `;\n        case 3:\n          return `\n          // transform: rotate(90deg);\n          // top: 145px;\n          // left: -86px;\n          width: ${defaultWidth}px;\n        `;\n        case 4:\n          return `\n          // transform: rotate(90deg);\n          // top: 145px;\n          // left: 15px;\n          width: ${defaultWidth}px;\n        `;\n        case 5:\n          return `\n          // transform: rotate(90deg);\n          // top: 145px;\n          // left: 115px;\n          width: ${defaultWidth}px;\n        `;\n        case 6:\n          return `\n          // transform: rotate(45deg);\n          // top: 145px;\n          // left: -44px;\n          width: ${diagonalWidth}px;\n        `;\n        case 7:\n          return `\n          // transform: rotate(-45deg);\n          // top: 145px;\n          // left: -46px;\n          width: ${diagonalWidth}px;\n        `;\n        default:\n          return null;\n      }\n    };\n    this.clone = () => {\n      return new Board(this.grid.concat());\n    };\n    // this.grid = grid || new Array(DIMS ** 2).fill(null);\n    // this.grid = grid || new Array(DIMS * (9)).fill(null);\n    this.grid = _grid || new Array(9).fill(null);\n    this.winningIndex = null;\n  }\n}\n// minimax\nexport const minimax = (board, player) => {\n  const mult = SCORES[String(player)];\n  let thisScore;\n  let maxScore = -1;\n  let bestMove = null;\n  if (board.getWinner() !== null) {\n    return [SCORES[board.getWinner()], 0];\n  } else {\n    for (let empty of board.getEmptySquares()) {\n      let copy = board.clone();\n      copy.makeMove(empty, player);\n      thisScore = mult * minimax(copy, switchPlayer(player))[0];\n      if (thisScore >= maxScore) {\n        maxScore = thisScore;\n        bestMove = empty;\n      }\n    }\n    return [mult * maxScore, bestMove];\n  }\n};\n\n// utils\nexport const DIMS = 3;\nexport const DRAW = 0;\nexport const PLAYER_X = 1;\nexport const PLAYER_O = 2;\nexport const SCORES = {\n  1: 1,\n  0: 0,\n  2: -1\n};\nexport const SQUARE_DIMS = 100;\nexport const GAME_STATES = {\n  notStarted: \"not_started\",\n  inProgress: \"in_progress\",\n  over: \"over\"\n};\nexport const GAME_MODES = {\n  easy: \"easy\",\n  medium: \"medium\",\n  difficult: \"difficult\"\n};\nexport const switchPlayer = player => {\n  return player === PLAYER_X ? PLAYER_O : PLAYER_X;\n};\nexport const getRandomInt = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};","map":{"version":3,"names":["Board","constructor","grid","makeMove","square","player","getEmptySquares","squares","forEach","i","push","isEmpty","length","DIMS","getWinner","winningCombos","res","el","winningIndex","DRAW","getStrikethroughStyles","defaultWidth","diagonalWidth","clone","concat","Array","fill","minimax","board","mult","SCORES","String","thisScore","maxScore","bestMove","empty","copy","switchPlayer","PLAYER_X","PLAYER_O","SQUARE_DIMS","GAME_STATES","notStarted","inProgress","over","GAME_MODES","easy","medium","difficult","getRandomInt","min","max","Math","ceil","floor","random"],"sources":["C:/Users/olefi/OneDrive/Рабочий стол/tictactoereact/src/components/AiBoard.jsx"],"sourcesContent":["export default class Board {\r\n  constructor(grid) {\r\n    // this.grid = grid || new Array(DIMS ** 2).fill(null);\r\n    // this.grid = grid || new Array(DIMS * (9)).fill(null);\r\n    this.grid = grid || new Array(9).fill(null);\r\n    this.winningIndex = null;\r\n  }\r\n\r\n  makeMove = (square, player) => {\r\n    if (this.grid[square] === null) {\r\n      this.grid[square] = player;\r\n    }\r\n  };\r\n\r\n  // Collect indices of empty squares and return them\r\n  getEmptySquares = (grid = this.grid) => {\r\n    let squares = [];\r\n    grid.forEach((square, i) => {\r\n      if (square === null) squares.push(i);\r\n    });\r\n    return squares;\r\n  };\r\n\r\n  isEmpty = (grid = this.grid) => {\r\n    return this.getEmptySquares(grid).length === DIMS ** 2;\r\n  };\r\n\r\n  getWinner = (grid = this.grid) => {\r\n    const winningCombos = [\r\n      [0, 1, 2],\r\n      [3, 4, 5],\r\n      [6, 7, 8],\r\n      [0, 3, 6],\r\n      [1, 4, 7],\r\n      [2, 5, 8],\r\n      [0, 4, 8],\r\n      [2, 4, 6]\r\n    ];\r\n    let res = null;\r\n    winningCombos.forEach((el, i) => {\r\n      if (\r\n        grid[el[0]] !== null &&\r\n        grid[el[0]] === grid[el[1]] &&\r\n        grid[el[0]] === grid[el[2]]\r\n      ) {\r\n        res = grid[el[0]];\r\n        this.winningIndex = i;\r\n      } else if (res === null && this.getEmptySquares(grid).length === 0) {\r\n        res = DRAW;\r\n        this.winningIndex = null;\r\n      }\r\n    });\r\n    return res;\r\n  };\r\n\r\n  \r\n  // Get the styles for strike through based on the combination that won\r\n\r\n  getStrikethroughStyles = () => {\r\n    const defaultWidth = 285;\r\n    const diagonalWidth = 400;\r\n    switch (this.winningIndex) {\r\n      case 0:\r\n        return `\r\n          // transform: none;\r\n          // top: 61px;\r\n          // left: 15px;\r\n          width: ${defaultWidth}px;\r\n        `;\r\n      case 1:\r\n        return `\r\n          // transform: none;\r\n          // top: 140px;\r\n          // left: 15px;\r\n          width: ${defaultWidth}px;\r\n        `;\r\n      case 2:\r\n        return `\r\n          // transform: none;\r\n          // top: 242px;\r\n          // left: 15px;\r\n          width: ${defaultWidth}px;\r\n        `;\r\n      case 3:\r\n        return `\r\n          // transform: rotate(90deg);\r\n          // top: 145px;\r\n          // left: -86px;\r\n          width: ${defaultWidth}px;\r\n        `;\r\n      case 4:\r\n        return `\r\n          // transform: rotate(90deg);\r\n          // top: 145px;\r\n          // left: 15px;\r\n          width: ${defaultWidth}px;\r\n        `;\r\n      case 5:\r\n        return `\r\n          // transform: rotate(90deg);\r\n          // top: 145px;\r\n          // left: 115px;\r\n          width: ${defaultWidth}px;\r\n        `;\r\n      case 6:\r\n        return `\r\n          // transform: rotate(45deg);\r\n          // top: 145px;\r\n          // left: -44px;\r\n          width: ${diagonalWidth}px;\r\n        `;\r\n      case 7:\r\n        return `\r\n          // transform: rotate(-45deg);\r\n          // top: 145px;\r\n          // left: -46px;\r\n          width: ${diagonalWidth}px;\r\n        `;\r\n      default:\r\n        return null;\r\n    }\r\n  };\r\n\r\n  clone = () => {\r\n    return new Board(this.grid.concat());\r\n  };\r\n}\r\n// minimax\r\nexport const minimax = (board, player) => {\r\n  const mult = SCORES[String(player)];\r\n  let thisScore;\r\n  let maxScore = -1;\r\n  let bestMove = null;\r\n\r\n  if (board.getWinner() !== null) {\r\n    return [SCORES[board.getWinner()], 0];\r\n  } else {\r\n    for (let empty of board.getEmptySquares()) {\r\n      let copy = board.clone();\r\n      copy.makeMove(empty, player);\r\n      thisScore = mult * minimax(copy, switchPlayer(player))[0];\r\n\r\n      if (thisScore >= maxScore) {\r\n        maxScore = thisScore;\r\n        bestMove = empty;\r\n      }\r\n    }\r\n\r\n    return [mult * maxScore, bestMove];\r\n  }\r\n};\r\n\r\n// utils\r\nexport const DIMS = 3;\r\nexport const DRAW = 0;\r\nexport const PLAYER_X = 1;\r\nexport const PLAYER_O = 2;\r\nexport const SCORES = {\r\n  1: 1,\r\n  0: 0,\r\n  2: -1\r\n};\r\nexport const SQUARE_DIMS = 100;\r\nexport const GAME_STATES = {\r\n  notStarted: \"not_started\",\r\n  inProgress: \"in_progress\",\r\n  over: \"over\"\r\n};\r\n\r\nexport const GAME_MODES = {\r\n  easy: \"easy\",\r\n  medium: \"medium\",\r\n  difficult: \"difficult\"\r\n};\r\n\r\nexport const switchPlayer = player => {\r\n  return player === PLAYER_X ? PLAYER_O : PLAYER_X;\r\n};\r\n\r\nexport const getRandomInt = (min, max) => {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n};\r\n\r\n"],"mappings":"AAAA,eAAe,MAAMA,KAAK,CAAC;EACzBC,WAAW,CAACC,KAAI,EAAE;IAAA;IAAA,KAOlBC,QAAQ,GAAG,CAACC,MAAM,EAAEC,MAAM,KAAK;MAC7B,IAAI,IAAI,CAACH,IAAI,CAACE,MAAM,CAAC,KAAK,IAAI,EAAE;QAC9B,IAAI,CAACF,IAAI,CAACE,MAAM,CAAC,GAAGC,MAAM;MAC5B;IACF,CAAC;IAAA,KAGDC,eAAe,GAAG,YAAsB;MAAA,IAArBJ,IAAI,uEAAG,KAAI,CAACA,IAAI;MACjC,IAAIK,OAAO,GAAG,EAAE;MAChBL,IAAI,CAACM,OAAO,CAAC,CAACJ,MAAM,EAAEK,CAAC,KAAK;QAC1B,IAAIL,MAAM,KAAK,IAAI,EAAEG,OAAO,CAACG,IAAI,CAACD,CAAC,CAAC;MACtC,CAAC,CAAC;MACF,OAAOF,OAAO;IAChB,CAAC;IAAA,KAEDI,OAAO,GAAG,YAAsB;MAAA,IAArBT,IAAI,uEAAG,KAAI,CAACA,IAAI;MACzB,OAAO,KAAI,CAACI,eAAe,CAACJ,IAAI,CAAC,CAACU,MAAM,KAAKC,IAAI,IAAI,CAAC;IACxD,CAAC;IAAA,KAEDC,SAAS,GAAG,YAAsB;MAAA,IAArBZ,IAAI,uEAAG,KAAI,CAACA,IAAI;MAC3B,MAAMa,aAAa,GAAG,CACpB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CACV;MACD,IAAIC,GAAG,GAAG,IAAI;MACdD,aAAa,CAACP,OAAO,CAAC,CAACS,EAAE,EAAER,CAAC,KAAK;QAC/B,IACEP,IAAI,CAACe,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,IACpBf,IAAI,CAACe,EAAE,CAAC,CAAC,CAAC,CAAC,KAAKf,IAAI,CAACe,EAAE,CAAC,CAAC,CAAC,CAAC,IAC3Bf,IAAI,CAACe,EAAE,CAAC,CAAC,CAAC,CAAC,KAAKf,IAAI,CAACe,EAAE,CAAC,CAAC,CAAC,CAAC,EAC3B;UACAD,GAAG,GAAGd,IAAI,CAACe,EAAE,CAAC,CAAC,CAAC,CAAC;UACjB,KAAI,CAACC,YAAY,GAAGT,CAAC;QACvB,CAAC,MAAM,IAAIO,GAAG,KAAK,IAAI,IAAI,KAAI,CAACV,eAAe,CAACJ,IAAI,CAAC,CAACU,MAAM,KAAK,CAAC,EAAE;UAClEI,GAAG,GAAGG,IAAI;UACV,KAAI,CAACD,YAAY,GAAG,IAAI;QAC1B;MACF,CAAC,CAAC;MACF,OAAOF,GAAG;IACZ,CAAC;IAAA,KAKDI,sBAAsB,GAAG,MAAM;MAC7B,MAAMC,YAAY,GAAG,GAAG;MACxB,MAAMC,aAAa,GAAG,GAAG;MACzB,QAAQ,IAAI,CAACJ,YAAY;QACvB,KAAK,CAAC;UACJ,OAAQ;AAChB;AACA;AACA;AACA,mBAAmBG,YAAa;AAChC,SAAS;QACH,KAAK,CAAC;UACJ,OAAQ;AAChB;AACA;AACA;AACA,mBAAmBA,YAAa;AAChC,SAAS;QACH,KAAK,CAAC;UACJ,OAAQ;AAChB;AACA;AACA;AACA,mBAAmBA,YAAa;AAChC,SAAS;QACH,KAAK,CAAC;UACJ,OAAQ;AAChB;AACA;AACA;AACA,mBAAmBA,YAAa;AAChC,SAAS;QACH,KAAK,CAAC;UACJ,OAAQ;AAChB;AACA;AACA;AACA,mBAAmBA,YAAa;AAChC,SAAS;QACH,KAAK,CAAC;UACJ,OAAQ;AAChB;AACA;AACA;AACA,mBAAmBA,YAAa;AAChC,SAAS;QACH,KAAK,CAAC;UACJ,OAAQ;AAChB;AACA;AACA;AACA,mBAAmBC,aAAc;AACjC,SAAS;QACH,KAAK,CAAC;UACJ,OAAQ;AAChB;AACA;AACA;AACA,mBAAmBA,aAAc;AACjC,SAAS;QACH;UACE,OAAO,IAAI;MAAC;IAElB,CAAC;IAAA,KAEDC,KAAK,GAAG,MAAM;MACZ,OAAO,IAAIvB,KAAK,CAAC,IAAI,CAACE,IAAI,CAACsB,MAAM,EAAE,CAAC;IACtC,CAAC;IA3HC;IACA;IACA,IAAI,CAACtB,IAAI,GAAGA,KAAI,IAAI,IAAIuB,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;IAC3C,IAAI,CAACR,YAAY,GAAG,IAAI;EAC1B;AAwHF;AACA;AACA,OAAO,MAAMS,OAAO,GAAG,CAACC,KAAK,EAAEvB,MAAM,KAAK;EACxC,MAAMwB,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC1B,MAAM,CAAC,CAAC;EACnC,IAAI2B,SAAS;EACb,IAAIC,QAAQ,GAAG,CAAC,CAAC;EACjB,IAAIC,QAAQ,GAAG,IAAI;EAEnB,IAAIN,KAAK,CAACd,SAAS,EAAE,KAAK,IAAI,EAAE;IAC9B,OAAO,CAACgB,MAAM,CAACF,KAAK,CAACd,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;EACvC,CAAC,MAAM;IACL,KAAK,IAAIqB,KAAK,IAAIP,KAAK,CAACtB,eAAe,EAAE,EAAE;MACzC,IAAI8B,IAAI,GAAGR,KAAK,CAACL,KAAK,EAAE;MACxBa,IAAI,CAACjC,QAAQ,CAACgC,KAAK,EAAE9B,MAAM,CAAC;MAC5B2B,SAAS,GAAGH,IAAI,GAAGF,OAAO,CAACS,IAAI,EAAEC,YAAY,CAAChC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;MAEzD,IAAI2B,SAAS,IAAIC,QAAQ,EAAE;QACzBA,QAAQ,GAAGD,SAAS;QACpBE,QAAQ,GAAGC,KAAK;MAClB;IACF;IAEA,OAAO,CAACN,IAAI,GAAGI,QAAQ,EAAEC,QAAQ,CAAC;EACpC;AACF,CAAC;;AAED;AACA,OAAO,MAAMrB,IAAI,GAAG,CAAC;AACrB,OAAO,MAAMM,IAAI,GAAG,CAAC;AACrB,OAAO,MAAMmB,QAAQ,GAAG,CAAC;AACzB,OAAO,MAAMC,QAAQ,GAAG,CAAC;AACzB,OAAO,MAAMT,MAAM,GAAG;EACpB,CAAC,EAAE,CAAC;EACJ,CAAC,EAAE,CAAC;EACJ,CAAC,EAAE,CAAC;AACN,CAAC;AACD,OAAO,MAAMU,WAAW,GAAG,GAAG;AAC9B,OAAO,MAAMC,WAAW,GAAG;EACzBC,UAAU,EAAE,aAAa;EACzBC,UAAU,EAAE,aAAa;EACzBC,IAAI,EAAE;AACR,CAAC;AAED,OAAO,MAAMC,UAAU,GAAG;EACxBC,IAAI,EAAE,MAAM;EACZC,MAAM,EAAE,QAAQ;EAChBC,SAAS,EAAE;AACb,CAAC;AAED,OAAO,MAAMX,YAAY,GAAGhC,MAAM,IAAI;EACpC,OAAOA,MAAM,KAAKiC,QAAQ,GAAGC,QAAQ,GAAGD,QAAQ;AAClD,CAAC;AAED,OAAO,MAAMW,YAAY,GAAG,CAACC,GAAG,EAAEC,GAAG,KAAK;EACxCD,GAAG,GAAGE,IAAI,CAACC,IAAI,CAACH,GAAG,CAAC;EACpBC,GAAG,GAAGC,IAAI,CAACE,KAAK,CAACH,GAAG,CAAC;EACrB,OAAOC,IAAI,CAACE,KAAK,CAACF,IAAI,CAACG,MAAM,EAAE,IAAIJ,GAAG,GAAGD,GAAG,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG;AAC1D,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}